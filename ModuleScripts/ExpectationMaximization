local module = {}

local AqwamMatrixLibrary = require(script.Parent.AqwamRobloxMatrixLibraryLinker.Value)

local defaultEpsilon = 1 * math.exp(-5)

local defaultMaxNumberOfIterations = 500

local function calculateFactorial(x)
	
	if (x > 1) then
		
		return x * calculateFactorial(x-1)
		
	else
		
		return x
		
	end
	
end

local function calculatePoisson(featureVector, meanVector)
	
	local negativeMeanVector = AqwamMatrixLibrary:multiply(-1, meanVector)
	
	local expNegativeMeanVector = AqwamMatrixLibrary:applyFunction(math.exp, negativeMeanVector)
	
	local factorialFeatureVector = AqwamMatrixLibrary:applyFunction(calculateFactorial, featureVector)
	
	local inverseFactorialFeatureVector = AqwamMatrixLibrary:divide(1, factorialFeatureVector)
	
	return AqwamMatrixLibrary:multiply(featureVector, meanVector, expNegativeMeanVector, inverseFactorialFeatureVector)
	
end

local function calculatePosteriorProbability(featureMatrix, meanMatrix, probabilities)
	
	local featureVector
	
	local meanVector
	
	local eachClass
	
	local eachClassSum
	
	local probability
	
	local poisson
	
	local posterior = AqwamMatrixLibrary:createMatrix(3,2)
	
	for i = 1, #featureMatrix, 1 do
		
		featureVector = {featureMatrix[i]}
		
		for j = 1, #meanMatrix, 1 do
			
			meanVector = {meanMatrix[j]}
			
			probability = {probabilities[j]}
			
			poisson = calculatePoisson(featureVector, meanMatrix)
			
			eachClass = AqwamMatrixLibrary:multiply(poisson, probability)
			
		end
		
		eachClassSum = AqwamMatrixLibrary:sum(eachClass)
		
		posterior = AqwamMatrixLibrary:add(posterior, AqwamMatrixLibrary:divide(eachClass, eachClassSum))
		
	end
	
	return posterior
	
end

local function calculateOptimalProbability(posteriorMatrix)
	
	local numberOfProbabilities = #posteriorMatrix
	
	local posteriorMatrixSum = AqwamMatrixLibrary:verticalSum(posteriorMatrix)
	
	local probabilitiesMatrix = {}
	
	local probability
	
	local posteriorVector
	
	for i = 1, numberOfProbabilities, 1 do
		
		posteriorVector = {posteriorMatrix[i]}
		
		probability = AqwamMatrixLibrary:divide(posteriorVector, posteriorMatrixSum)
		
		probabilitiesMatrix[i] = probability[1]
		
	end
	
	return probabilitiesMatrix
	
end

local function calculateOptimalMean(featureMatrix, posteriorMatrix)
	
	local featureVector
	
	local posteriorVector
	
	local transposedPosteriorVector
	
	local Numerator
	
	local NumeratorSum
	
	local newMeanVector
	
	local posteriorVectorSum
	
	local newMeanMatrix = {}
	
	local featureVector 

	for i = 1, #posteriorMatrix, 1 do

		posteriorVector = {posteriorMatrix[i]}
		
		Numerator = {}
		
		for j = 1, #featureMatrix, 1 do
			
			featureVector = {featureMatrix[j]}
			
			Numerator[j] = AqwamMatrixLibrary:multiply(featureVector, posteriorVector)[1] -- [1] is added so that we remove 1 dimension to merge with the Numerator
			
		end
		
		NumeratorSum = AqwamMatrixLibrary:verticalSum(Numerator)
		
		newMeanVector = AqwamMatrixLibrary:divide(NumeratorSum, posteriorVector)
		
		newMeanMatrix[i] = newMeanVector[1] -- [1] is added so that we remove 1 dimension to merge with the newMeanMatrix
 		
	end
	
	return newMeanMatrix
	
end


function module:train(featureMatrix, numberOfClusters, maxNumberOfIterations, epsilon, suppressOutput)
	
	local incompletes = {}
	
	local cost = 1
	
	epsilon = epsilon or defaultEpsilon
	
	maxNumberOfIterations = maxNumberOfIterations or defaultMaxNumberOfIterations
	
	local posteriorMatrix
	
	local probabilitiesMatrix = AqwamMatrixLibrary:createRandomNormalMatrix(numberOfClusters, #featureMatrix[1])
	
	local meanMatrix = AqwamMatrixLibrary:createRandomNormalMatrix(numberOfClusters, #featureMatrix[1])
	
	local incompleteLogLikelihood
	
	local current
	
	local previous
	
	local numberOfIterations = 0
	
	repeat
		
		numberOfIterations += 1
		
		posteriorMatrix = calculatePosteriorProbability(featureMatrix, meanMatrix, probabilitiesMatrix)
		
		probabilitiesMatrix = calculateOptimalProbability(posteriorMatrix)
		
		meanMatrix = calculateOptimalMean(featureMatrix, posteriorMatrix)
		
		if (not suppressOutput) then print("Iteration: " .. numberOfIterations .. "\t\tCost: " .. cost) end
		
	until (maxNumberOfIterations == numberOfIterations) or (cost <= epsilon)
	
	return meanMatrix, probabilitiesMatrix
	
end

return module
